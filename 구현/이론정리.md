## 구현
#### 구현이란? 
구현이란,  **머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정**입니다.

problem - thinking - solution

+ 흔히 알고리즘 대회에서 구현 유형의 문제란 무엇을 의미할까?
+ **풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제**를 지칭한다.
+ 구현 유형의 예시는 다음과 같습니다.
+ 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제
+ 실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제
+ 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
+ 적절한 라이브러리를 찾아서 사용해야 하는 문제

일반적으로 알고리즘 문제에서의 2차원 공간은 **행렬(Matrix)** 의 의미로 사용됩니다.


## "구현" 이란 
머릿속에 있는 알고리즘을 정확하고 빠르게 프로그램으로 작성하기
 

구현 파트는 다른 파트와는 다르게 별다른 특별한 방법없이 "묵묵히 주어진대로 구현" 하는 파트이다.

## 구현의 특징
## ✓ 완전탐색 : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
## ✓ 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례로 직접 수행
 
 

+ ### **Key point** " 반복문을 통해 전체 케이스를 올바르게 잘 나눌 수 있는가? "

### **" 입력 숫자의 범위 "** 와 **" 제한된 용량 "** , **" 제한된 시간 "** 을 주의해야 한다는 점이다.

#### 숫자를 저장하는 리스트의 경우 용량을 생각하며 작성해야 한다.
+ " 메모리 제한 : 128MB " 보통의 문제의 경우 128MB를 제한으로 둔다. 이때, 1,000만 : 약 40MB를 차지하므로
+ " 리스트 길이를 최대 10,000,000 으로 두고 작성해야 한다 " 
+ "시간 제한 : 1초 "
+ " 약 20,000,000회 연산, 시간복잡도 O(NlogN) "

### 코드 예시
1. "이동" + "시뮬레이션"
5✕5 크기의 지도에서 현재 (1,1) 위치에 있다. 명령어 "L", "R", "U", "D"를 통해 사방으로 움직인 후 최종위치를 출력한다. (다만, 지도를 벗어나는 명령어의 경우 무시된다)
-> 명령어 : R R R U D D

이 문제의 경우 명령에 따라 한번씩 "이동" 시키는 대표적인 "시뮬레이션" 유형의 문제이다.
이러한 이동이 있는 문제의 경우 아래 두가지 문법 중 하나를 사용하게 된다

1) dx, dy 리스트 방법
```python
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
```

-> 이동시 쓰이는 코드
```python
nx = x + dx[i]
ny = y + dy[i]
```

2) move 리스트 방법
```python
move = [(0,-1), (0,1), (-1,0), (1,0)]
```
-> 이동시 쓰이는 코드
```python
nx = x+move[i][0]
ny = y+move[i][1]
```

또한, 같이 쓰이는 방법 중 하나로, 명령어가 주어지는 경우 하나하나 if 문을 통해 체크하는 방법보다는
```python
move_types = ['L', 'R', 'U', 'D']
```

이렇게 명령어를 리스트로 만들어 for문을 통해 index로 접근하는 것이 더욱 깔끔하다.

따라서 위의 이동 기술에 따라 코드를 구현하자면

```python
move = [(0,-1), (0,1), (-1,0), (1,0)]
move_types = ['L', 'R', 'U', 'D'] 

for plan in plans :
  for i in range(len(move_types)) :
    if plan == move_types[i] : #이동방향 구하기
      nx = x + move[i][0]
      ny = y + move[i][1]
      
    if nx < 1 or ny < 1 or nx > 5 or ny > 5 : #이동 후 위치가 지도를 벗어나는 경우
      continue #이동하지 않고 다음 명령을 본다
    x, y = nx, ny #정상범위인 경우 이동한다

print(x, y)
```

### check point
1. for 문을 통해 명령어 리스트와 비교하여 인덱스 구하기
2. 해당 인덱스의 방향을 가져와 다음위치 구하기
3. 문제 지시에 따라 다음위치가 적절한지 여부에 따라 행동하기
